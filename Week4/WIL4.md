## 순차 지향 프로그래밍과 절차 지향 프로그래밍 특징과 차이

### 순차 지향 프로그래밍

- 말 그대로 순차적으로 흘러가는 프로그래밍 구조
- 즉, 코드의 흐름이나 순서에 기반하여 프로그래밍함
- 구조가 존재하지 않음
    - 따라서 goto문을 이용하여 코드를 짜게 됨
    → 여기서 문제가 발생한다
    - goto문이 많아질 수록 흐름이 복잡해져 코드의 이해가 어려워짐
    - 코드를 단위화할 방법이 필요해짐

### 절차 지향 프로그래밍

- 절차란 곧 프로시저(Procedure)를 의미
    - 프로시저(Procedure)란?
        - return 값이 없고 실행이 주가되는 함수
- 반복될 가능성이 있는 모듈을 재사용 가능한 프로시저 단위로 나눈 프로그래밍을 곧 절차 지향 프로그래밍이라고 함
- 즉, 반복될 가능성이 있는 부분을 프로시저로 쪼개고, 프로시저 안에서 중복되는 부분은 for문과 같은 반복문으로 구성한다

### 차이점

- 절차, 즉 프로시저라는 개념이 존재하는지가 가장 큰 차이점
- 순차 지향은 코드의 흐름만을 생각하지만, 절차 지향은 흐름에 따라 중복될 가능성이 있는 코드들을 하나의 프로시저로 합쳐 재사용을 높인다

## JVM의 역할과 가비지컬렉션(GC)이란?

### JVM(Java Virtual Machine)

- 운영체제 위에서 동작하는 프로세스
- 자바 코드를 컴파일해서 얻은 바이트 코드를 해당 운영체제가 이해할 수 있는 기계어로 바꿔 실행시켜주는 역할을 함
- 따라서 Java는 플랫폼 독립적이라는 특징을 얻을 수 있음

### Java 실행 과정

1. Java 소스 코드 파일 작성
2. 컴파일 에러가 없는 경우 Java 컴파일러가 소스 코드를 바이트 코드(.class)로 변환
3. 바이트 코드는 class loader에 의해 JVM으로 로드 됨
4. 바이트 코드 검증 도구가 바이트 코드의 무결성을 확인하고 문제가 없을 경우 인터프리터에 전달
5. JVM 내부의 인터프리터가 바이트 코드의 각 행을 실행 가능한 기계 코드로 변환하고, 이를 OS에 전달

### JVM의 역할

- Java 어플리케이션을 클래스 로더를 통해 읽어들여 자바 API와 함께 실행
- Java와 OS 사이의 중개자 역할을 수행
    - OS에 구애받지 않음. 독립적
- 메모리 관리(Garbage Collection) 수행

### Garbage Collection

- 프로그램 개발 시, 유효하지 않은 메모리인 가비지(Garbage)가 발생
    - 예를 들어, C에서 malloc을 통해 heap영역에 메모리를 동적하는 경우 메모리 공간을 직접 free 해주어야 함
- JVM의 가비지 컬렉터는 불필요한 메모리를 자동으로 정리해줌
    - 즉, C와 같이 메모리 해제를 직접하지 않음
- 예를 들면 다음과 같다.
    
    ```java
    Myclass obj = new Myclass();
    obj.setData(100); // 객체 사용
    
    obj = null; // 가비지 발생
    ```
    
    - 이 경우 obj 객체는 더 이상 참조를 하지 않고 사용도 되지 않아 가비지가 됨
    - 가비지 컬렉터(Garbage Collector)는 주기적으로 이러한 메모리 누수를 검사하여 제거함

## 메소드, 힙, 스택 영역에 각각 어떤 게 존재하는가?

### 메소드, 힙, 스택 영역

- JVM이 메모리를 OS에게 요청하면 OS는 메모리를 할당함
- 이 때 받은 메모리를 메소드 영역, 스택 영역, 힙 영역으로 메모리 구조를 나눌 수 있음

### 메소드 영역

- 클래스 영역 또는 정적 영역이라고 함
- 프로그램 실행을 위한 바이트 코드 저장
- 전역 변수와 static 멤버 변수, 상수 저장

### 힙 영역

- new로 생성된 인스턴스 변수 저장
- 메소드 호출이 끝나도 제거되지 않음

### 스택 영역

- 지역변수, 매개변수, 반환 값 저장
- 메소드 호출 시마다 저장하고, 메소드가 끝나면 제거 됨

## 클래스는 붕어빵 틀이고 객체는 붕어빵이다?

클래스는 객체를 생성하기 위한 설계도이고, 객체는 클래스를 통해 실제 메모리 공간을 할당받아 생성된 인스턴스이므로 붕어빵 틀과 붕어빵의 비유가 어느정도 맞는듯 보인다.

하지만 완전한 비유일 수는 없는데, 우선 붕어빵 틀과 달리 클래스는 상속의 개념이 존재한다. 즉, 클래스는 또 다른 클래스를 상속 받아 사용할 수 있다. 하지만 붕어빵 틀이 다른 틀을 상속 받거나, 또는 다른 틀에 상속되는 것을 상상하기는 어렵다.

둘째로, 클래스로 생성된 객체는 실제하는 메모리 주소에 할당되게 된다. 하지만 붕어빵은 만들어진 후 어떤 특정 공간에 할당되지 않는다.

마지막으로 객체는 특정 상태에 따라 다른 객체가 생성된다. 즉, 클래스에 정의된 속성과 기능을 가지면서도 각각의 객체 자신만의 상태를 갖는다. 붕어빵은 모두 같은 모양과 같은 맛을 갖기 때문에(물론 팥 붕어빵, 슈크림 붕어빵과 같은 종류가 나뉠 수 있지만, 객체처럼 생성될 때마다 각각의 상태를 가질 수 없다.) 이 또한 차이점이라 할 수 있다.

즉 요약하자면, 클래스는 붕어빵 틀이고 객체는 붕어빵이다라는 말은 클래스를 통해 객체를 ‘생성’하는데에만 초점이 맞춰진 비유이므로 완전한 비유는 아니다. 다만 처음 클래스와 객체에 대한 개념이 아예 없을 때, 클래스를 통해 객체를 생성한다는 걸 설명하기 위한 비유로는 최적이라고 생각한다.
